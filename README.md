# Генератор решаемых полей игры «Сапёр"

Программное средство «Генератор решаемых полей игры Сапёр» предназначено для автоматической генерации игровых полей, проверки их детерминистической решаемости, отображения результата в консоли и сохранения корректных полей в текстовый файл.

---

# 1) Постановка задачи

Игра «Сапёр» — логическая головоломка на прямоугольной сетке. На поле случайно размещены мины; у каждой неминной клетки есть число, равное количеству мин в 8 соседних клетках. Игрок открывает клетки и, опираясь на числа, должен пометить все мины без угадываний.

Цель проекта — создать консольную программу, которая:

- генерирует случайное поле заданных размеров и плотности мин;
- проверяет, является ли поле **детерминистически решаемым** (решаемым локальными логическими правилами без перебора и угадываний);
- при необходимости многократно перегенерирует поле в пределах практического лимита попыток (`MAX_ATTEMPTS`);
- обеспечивает ASCII‑визуализацию поля, автоматическую валидацию счётчиков и сохранение корректных полей в файл;
- обрабатывает некорректный ввод и граничные случаи.

## 2) Структура проекта

repos/

├── Minesweeper_prj/

│   ├── .gitattributes

│   ├── .gitignore

│   └── field.h

│   └── field.c

│   └── main.c

│   └── Minesweeper_prj.slnx

│   └── Minesweeper_prj.vcxproj

│   └── Minesweeper_prj.vcxproj.filters

│   └── README.md


## 3) Ключевые функции

### 1. `Field* field_create(int rows, int cols)`
- **Назначение**: выделяет память и инициализирует структуру поля (`rows`, `cols`, массивы `is_mine` и `count`).
- **Параметры**:
  - `rows` — число строк;
  - `cols` — число столбцов.
- **Возвращает**: указатель на `Field` или `NULL` при ошибке выделения памяти.

### 2. `void field_free(Field* f)`
- **Назначение**: освобождает память, занятую структурой поля (безопасно вызывать с `NULL`).
- **Параметры**: `f` — указатель на `Field`.

### 3. `void field_clear(Field* f)`
- **Назначение**: сбрасывает содержимое поля (удаляет все мины, обнуляет счётчики и счётчик мин), используется перед новой генерацией.
- **Параметры**: `f` — указатель на `Field`.

### 4. `void compute_counts(Field* f)`
- **Назначение**: вычисляет для каждой неминной клетки значение `count` — число мин в 8 соседних клетках.
- **Параметры**: `f` — указатель на `Field`.

### 5. `void generate_by_probability(Field* f, int percent)`
- **Назначение**: заполняет поле минами с заданной вероятностью `percent` (0..100) и вызывает `compute_counts`.
- **Параметры**:
  - `f` — указатель на `Field`;
  - `percent` — вероятность в процентах.

### 6. `void print_field_ascii(const Field* f, bool show_mines)`
- **Назначение**: печатает поле в консоль в формате ASCII-таблицы.
- **Параметры**:
  - `f` — указатель на `Field`;
  - `show_mines` — при `true` мины отображаются `*`.
- **Отображение**: `.` — ноль, `1..8` — числа, `*` — мина.

### 7. `bool validate_field(const Field* f)`
- **Назначение**: для каждой неминной клетки пересчитывает соседние мины и сравнивает с `f->count`. Печатает ошибки и возвращает `false`, если найдены несоответствия.
- **Параметры**: `f` — указатель на `Field`.

### 8. `bool simulate_solver_from(const Field* f, int start_r, int start_c)`
- **Назначение**: имитирует детерминистический (локальный) солвер, запускаемый из указанной стартовой клетки.
- **Параметры**:
  - `f` — указатель на `Field`;
  - `start_r`, `start_c` — координаты стартовой клетки.
- **Суть алгоритма**:
  - использует вспомогательные массивы `state` (`-1` = закрыта, `0..8` = открыта) и `inferred_mine` (внутренние пометки о минах);
  - BFS раскрытие нулевых областей (queue);
  - повторное применение локальных правил: если `n == known + unknown` -> unknown = мины; если `n == known` -> unknown = безопасны (открыть);
  - возвращает `true`, если открыты все безопасные клетки, иначе `false`.

### 9. `bool check_solvability(const Field* f, int* out_r, int* out_c)`
- **Назначение**: перебирает все неминные клетки и вызывает `simulate_solver_from` для каждой. Если для какой‑то стартовой клетки солвер открывает все безопасные клетки, функция возвращает `true` и опционально записывает координаты в `out_r`/`out_c`.
- **Параметры**: `f`, `out_r`, `out_c`.

## 4) Контрольные примеры
Было проведено несколько тестирований, вводные данные и результат представлены на сриншотах:
<img width="716" height="314" alt="image" src="https://github.com/user-attachments/assets/f1878584-85e6-4f93-919b-06981d15a911" />
<img width="881" height="354" alt="image" src="https://github.com/user-attachments/assets/8b1cfa8d-78b9-4a36-9f1a-f5952fda2c98" />
<img width="571" height="493" alt="image" src="https://github.com/user-attachments/assets/6c30274a-4597-47ca-b5ed-def0a71c2628" />
<img width="872" height="169" alt="image" src="https://github.com/user-attachments/assets/b9d60746-c0ac-48d2-ae9a-e3b1d103211a" />




## 5) Формат данных

- <b>Поле (Field):</b> Хранится как линейны массив длины rows * cols:

  - is mine — для каждой клетки: 1 - мина, 0 - нет

  - count — число мин среди 8 соседей(0..8)

